##### Wireless ESP32 driver ###
_w = 5 # wifi, bluetooth connection status
_s = 4 # socket connection status
dim b0[1024] # this buffer b0 is used everywhere, do not touch
 
AsIo(1)  # optional, in case user wants to talk to device during initialize ESP 
 
fn ClearBuf(b0) 
    for i = 0 to len(b0)
        b0[i] = 0
    next
fend
 
fn strlen(b0)
    for i = 0 to len(b0)
        if b0[i] = 0
            return i
        end
    next
fend
 
# Sent AT command 
fn AtCmd(b1) 
    SerWrs(b1)
    SerWr(13)
    SerWr(10) 
 
    # each command will be echo by cmd \r\n
    # normally a respone will be sent after around 15ms
    wait(20)
 
    r = AtGetLn(b0,100)
    #println(b0)
    return r
fend   
 
# Check AT command response
fn WaitOK(b0,t)    
    ClearBuf(b0)
 
    z = t
    i = 0
 
    while t > 0
        if SerB2R() = 0
            wait(1)
            t = t -1
        else
            t = z
            d = SerRd()
            b0[i]=d
            if d  = 10
                if (i >= 3)    
                    if b0[i-1] = 13 && b0[i-2] = 0x4B && b0[i-3] = 0x4F
                        return 1
                    end
                end
            end
            i = i + 1
        end
    wend
 
    return t # t = 0 timeout, not found
fend
 
# Read line from AT response 
fn AtGetLn(b0, t) # get line from AT 
    # AtGetLn will read all line, includes \r\n
    z = t
    i = 0
 
    ClearBuf(b0)
 
    while t > 0
        if SerB2R() = 0
            wait(1)
            t = t - 1
        else
            t = z # reset t when valid data
            d = SerRd()
            b0[i] = d
            i = i + 1
 
            if (d = 10) # new line
 
                break
            end
 
        end
    wend
 
    return i 
 
fend
 
# Read line from Downlink response 
fn DlGetLn(b0, t) # get line from AT 
    # AtGetLn will read all line, includes \r\n
    z = t
    i = 0
 
    ClearBuf(b0)
    dim b1[1]
 
    while t > 0
        if DLSer2R() = 0
            wait(2)
            t = t - 1
        else
            t = z # reset t when valid data
            DLSerRd(b1,1)
            b0[i] = b1[0]
            i = i + 1
 
            if (b1[0] = 10) # new line
                wait(2)
 
                # downlnk can send \r\n> or \r\n\r\n>
                while DLSer2R() > 0
                    DLSerRd(b1,1)
                    b0[i] = b1[0]
 
                    i = i + 1
                    wait(2)
                wend
                break
            end
        end
    wend
 
    return i 
 
fend
 
# Send data from ESP to Downlink 
fn Esp2Dwlk(w)
    if w = 0 # parser for bluetooth
        AtGetLn(b0, 128) # get line include \r\n, timeout 128ms since max 128 character * 1ms (9600)
        # example: +BTDATA:1,abcd\r\n
        # Scan from end -2 (exclude \r\n) to start till see comma
        # only send data after comma
        for i = 0 to strlen(b0)
            if b0[i] = 0x2C # comma: 
                break
            end
        next
 
        dim b4[strlen(b0)-2 -i-1]
        ClearBuf(b4)
 
        i = i + 1 # move to next byte
        for x = i to strlen(b0) - 2 # minus \r\n
            b4[x-i] = b0[x]
        next
 
        DLSerWr(b4) # Write to downlink
 
        #println("ESP -> Downlink:", b4)
    else # parser for wifi
        AtGetLn(b0, 10) # first \r\n
        #println(b0)
        AtGetLn(b0, 10) # second \r\n
        #println(b0)
 
        #example: \r\n+IPD,0,12:Hello World!\r\n  => two \r\n, Bluetooth has one at the end
 
        for i = 0 to strlen(b0)
            if b0[i] = 0x3A #: after this is real data
                break
            end
        next
 
        dim b4[strlen(b0)-2 -i-1]
        ClearBuf(b4)
 
        i = i + 1 # move to next byte
        for x = i to strlen(b0) - 2 # minus \r\n
            b4[x-i] = b0[x]
            #println(fmt(b4[x-i]))
        next
 
 
        DLSerWr(b4) # Write to downlink
        #println("ESP -> Downlink:", b4)
    end
fend 
 
# Send data from Downlink to ESP
fn Dwlnk2Esp(w)  
    if w = 0
        v = DlGetLn(b0,128) # read from downlink till see \r\n
 
        dim b5[v]
        Memcpy(b5,0,b0,0,v)
 
        #println("Downlink -> ESP:", b5, ", size: ", v)
 
        dim b6[20]
        sprintf(b6, "AT+BTSPPSEND=0,%d", v)
 
        l = strlen(b6) + 2 
        b6[l-1] = 10
        b6[l-2] = 13
 
 
        # write to ESP
        # l is actual len because sprintf add 0 to last byte
        dim b4[l]
        for i = 0 to l
            b4[i]=b6[i]
        next
        # write to ESP
        SerWrs(b4)  
 
        # Wait for '>'
        r = 0
        while (r = 0 )
            if SerB2R() = 0
                wait(1)
            else
                if SerRd() = '>'
                    break
                end
            end
        wend
 
        # write b5 to ESP
        SerWrs(b5)
 
        # wait for OK
        WaitOK(b0,1000)
    else 
        v = DlGetLn(b0,128) # read from downlink till see \r\n
 
        dim b5[v]
        Memcpy(b5,0,b0,0,v)
 
 
        dim b6[20]
        sprintf(b6, "AT+CIPSEND=0,%d", v)
 
        l = strlen(b6) + 2 
        b6[l-1] = 10
        b6[l-2] = 13
 
        # write to ESP
        # l is actual len because sprintf add 0 to last byte
        dim b4[l]
        for i = 0 to l
            b4[i]=b6[i]
        next
        # write to ESP
        SerWrs(b4)  
 
 
        # ESP send ....\r\nOK\r\n\r\n>
        # Wait for '>'
        r = 0
        while (r = 0 )
            if SerB2R() = 0
                wait(2)
            else
                if SerRd() = '>'
                    break
                end
            end
        wend
 
        # write b5 to ESP
        # println("Downlink -> ESP:", b5, ", size: ", v)
        SerWrs(b5)
        WaitOK(b0,1000)
    end
 
fend
 
# socket connection status 
fn IsSockConn() 
    return dread(_s, 1) = 0 
fend 
 
# Device connection status: If Bluetooth then Bluetooth connection. If use WiFi then WiFi connection 
fn IsConn()
    return dread(_w, 1) = 0 
fend 
 
# General Initialize
fn Init()
 
 
    # Open HW UART1 UPLINK
    SerCfg(9600, 1024)  
 
    # reset ESP
    dwrite(19, 0)
    # Enable pin: 1: Normal mode, 0: Download mode
    dwrite(18,1) #IO0
    dwrite(24,1) #IO2 
    wait(100)
    dwrite(19, 1)
    wait(100)
 
 
    # Wait for ready
    t = 5000
    while (SerB2R() < 9) # wait for \r\nready\r\n
        t = t - 1
        wait(1000)
        #println(SerB2R())
    wend
 
 
    # \r\nready\r\n is always sent
    AtGetLn(b0, 1000) # \r\n
    AtGetLn(b0, 1000) #ready\r\n
    #println(b0)
 
    # ESP may show something like GOT IP.... because previous config. Clear them
    wait(1000)
 
    # clear all responses
    SerDisc() 
 
    # Start initialize
    # Start AT cmd
    AtCmd("AT+BTINIT=1")    
    WaitOK(b0,2000) 
 
    #Depen on WiFi or Bluetooth, user need initialize WiFi or Bluetooth
fend
 
fn EnterLder() # Enter loader mode
    statled(0,1, 0)
    # reset ESP
    dwrite(19, 0)
    # Enable pin: 
    dwrite(18,0) # 1: Normal mode, 0: Download mode
    dwrite(24,0) # 1: Normal mode, 0: Download mode
    wait(100)
    dwrite(19, 1)
    wait(100) 
 
    while 1
        wait(100) 
    wend
fend  
 
fn InitBt(b1, t) # b1 is Bluetooth name, t: 0: only init, 1: start bridge,
    # Start AT - Bluetooth cmd
    AtCmd("AT+BTSSP=0")
    WaitOK(b0,2000)
    #println(b0)
 
    AtCmd("AT+BTSPPINIT=2")
    WaitOK(b0,2000)
    #println(b0)
 
    dim b6[] = "AT+BTNAME=\""
    dim b5[len(b1) + len(b6) + 1]
 
    Memcpy(b5, 0, b6, 0, len(b6))
 
    Memcpy(b5, len(b6), b1, 0, len(b1))
 
    b5[len(b5)-1] = 34 # '"'
 
    AtCmd(b5) #AT+BTNAME=b1
    WaitOK(b0,2000)
    #println(b0)
 
    AtCmd("AT+BTSCANMODE=2")
    WaitOK(b0,2000)  
    #println(b0)
 
 
    AtCmd("AT+BTSPPSTART") 
    WaitOK(b0, 2000)
    #println(b0)
 
    if t = 0
        return
    end
    
    dlmode(2, 0) #DOWNLINK HOST MODE 
 
    wait(10)
 
    println("Waiting for connection...")
    _b = 0 # backup state
    _s = 0 # current state 
    _i = 0 
 
    while 1
        # read the gateway status pin
        _s = IsConn() 
 
        if _b != _s
            _b = _s
            if _s = 1 # connected
 
                println("Connected")
                AtGetLn(b0, 100)
            else
 
                println("Disconnected")
                AtGetLn(b0, 100)
            end
            println("Status: ", b0) 
        end
 
        if _s = 1
            # read from ESP, then write to downlink
            if (SerB2R() > 0) 
                wait(1) 
                Esp2Dwlk(0)
            end
 
            # read from downlink, the write to ESP
            if DLSer2R() > 0
                wait(1)
                Dwlnk2Esp(0)
            end
        end
    wend
    # end
fend
 
fn InitWiFi(b1, b2, t) # b1:SSID, b2: password, t: 0: only init, 1: start bridge,
    # Start AT - WiFi cmd
    if AtCmd("AT+CWMODE=1") != 0
        WaitOK(b0,100)
    end
 
    dim b5[9 + 1 + len(b1) + len(b2)]
    dim b6[] = "AT+CWJAP="
    memcpy(b5, 0, b6, 0, len(b6))
 
    memcpy(b5, 9, b1, 0, len(b1))
    b5[9 + len(b1)] = ','
    memcpy(b5, 9 + len(b1) + 1 , b2, 0, len(b2))
 
    AtCmd(b5)   
 
    c = 0
    while (!IsConn())
        wait(1000)
        c = c + 1
        println("Wait for get IP: ", c)
    wend
 
    WaitOK(b0,10000)
 
    AtCmd("AT+CIFSR")   
    WaitOK(b0,1000)
 
    AtCmd("AT+CIPMUX=1") 
    WaitOK(b0,1000)
 
    AtCmd("AT+CIPSERVER=1,8080")
    WaitOK(b0,1000)
 
    AtCmd("AT+MDNS=1,\"duelink\",\"_tcp\",80")
    WaitOK(b0,1000)
 
    if t = 0
        return
    end
 
    b = 0 # backup state
    s = 0 # current state
 
    i = 0 
    
    dlmode(2, 0) #DOWNLINK HOST MODE 
 
    wait(10)
 
    println("Waiting for connection...") 
    while 1
        # read the gateway status pin
        s = IsSockConn() 
 
        if b != s
            b = s
            if s = 1 # connected
                # when device connected, device will send CONNECT\r\n=> clear them
                AtGetLn(b0, 100)
            else
                # when device disconnected, device will send DISCONNECT\r\n=> clear them
                AtGetLn(b0, 100)
            end
            println("Status: ", b0)
        end
 
        if s = 1 # connected
            # write to downlink
            # PullEsp() # only need for passive mode
            if (SerB2R() > 0) 
                wait(1) 
                #AT command start with \r\n+IPD,x,y:abcd\r\r\n. x = 0 (socket), y = len, abcd\r: real command: len = 5
                Esp2Dwlk(1)
            end
 
            # read from downlink and send to ESP
            if DLSer2R() > 0
                wait(1) 
                Dwlnk2Esp(1)
            end
        end
 
    wend
 
fend
Init()
