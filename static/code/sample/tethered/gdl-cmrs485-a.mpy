# This sample runs on QT-PY 2040 adafruit, and may need i2c pullup module
# In this sample:
# Send 0 or 1 to another RS485 to control the LED status.
# Receive data from the RS485.

import time
import duelink 

from duelink import transport

sclPIN = machine.Pin(23)
sdaPIN = machine.Pin(22)
 
i2c = transport.I2CTransportController(sda=sdaPIN, scl=sclPIN)
due = duelink.DUELinkController(i2c)

# methods
def Initialize():
    EnableRx(True)
    EnableTx(False)
    due.Uart.Configuration(9600, 128)
    #due.Engine.ExecuteCommand("SerCfg(9600,128)")  # same thing

def EnableRx(value):
    v = 0 if value else 1
    due.Digital.Write(5, v)
    # due.Engine.ExecuteCommand(f"dwrite(5, {v})")  # same thing

def EnableTx(value):
    v = 1 if value else 0
    due.Digital.Write(6, v)
    # due.Engine.ExecuteCommand(f"dwrite(6, {v})")  # same thing

def WriteByte(b):
    EnableRx(False)
    EnableTx(True)
    due.Uart.WriteByte(b)
    #due.Engine.ExecuteCommand(f"SerWr({b})")  # same thing

    EnableTx(False)
    EnableRx(True)

def ReadByte():
    data = due.Uart.ReadByte()
    #data = due.Engine.ExecuteCommand("SerRd()")  # same thing
    return data

def ByteToRead():
    count = due.Uart.BytesToRead()
    #count = due.Engine.ExecuteCommand("SerB2R()")  # same thing
    return count

Initialize()
count = 0

while True:
    v = count % 2
    WriteByte(v)
    while ByteToRead() == 0:
        time.sleep(0.001)  # Sleep 1 ms
    
    print(f"Rx: {ReadByte()}")
    count += 1
    time.sleep(1)  # Sleep 1 second

