# This sample runs on QT-PY 2040 adafruit, and may need i2c pullup module
# In this sample:
# Receive GPS data from the module every second
# Parse and display the time, date, latitude, longitude, and speed
# Issue: Reading data is slow: https://github.com/ghi-electronics/duelink-libraries/issues/105

import time
import duelink 

from duelink import transport

sclPIN = machine.Pin(23)
sdaPIN = machine.Pin(22)
 
i2c = transport.I2CTransportController(sda=sdaPIN, scl=sclPIN)
due = duelink.DUELinkController(i2c)

# methods
def EnableReceive(en: bool):
    v = 1 if en else 0
    due.Digital.Write(3, en)

def DataToRead() -> int:
    b2r = due.Uart.BytesToRead()
    return b2r

def ReadData(data: bytearray) -> int:
    # Start receiving data
    EnableReceive(True)
    while DataToRead() < len(data):
        time.sleep_ms(100)  # Sleep 100 ms

    # More than 512 bytes, disable receiving to save bus traffic
    EnableReceive(False)
    # does not work if ReadBytes
    #total = due.Uart.ReadBytes(data, 2000)  # Timeout 2000 ms
    total = 512
    for i in range(0,total):
        data[i] = due.Uart.ReadByte()

    # Discard any remaining bytes
    due.Uart.Discard()

    return total

def ParseGNRMC(buffer: bytearray):
    # Convert bytes to ASCII string, skipping invalid characters
    data = ''.join(chr(b) for b in buffer if 0x20 <= b <= 0x7E or b in (10, 13))

    # Split by line endings
    lines = [line for line in data.replace('\r', '\n').split('\n') if line]

    for line in lines:
        if line.startswith("$GNRMC"):
            parts = line.split(',')

            if len(parts) < 12:
                print("Invalid GNRMC sentence.")
                continue

            timeStr = parts[1]
            status = parts[2]  # A = valid, V = invalid
            latStr = parts[3]
            latDir = parts[4]
            lonStr = parts[5]
            lonDir = parts[6]
            speedStr = parts[7]  # in knots
            dateStr = parts[9]

            if status != "A":
                print("GPS data invalid.")
                continue

            # Parse latitude
            latitude = ParseNMEACoordinate(latStr, latDir)
            # Parse longitude
            longitude = ParseNMEACoordinate(lonStr, lonDir)
            # Parse speed in knots to km/h
            try:
                speedKmh = float(speedStr) * 1.852
            except ValueError:
                speedKmh = 0

            # Parse time
            timeFormatted = ParseNMEATime(timeStr)
            # Parse date
            dateFormatted = ParseNMEADate(dateStr)

            # Print results
            print("======================")
            print("Time:", timeFormatted)
            print("Date:", dateFormatted)
            print("Latitude: {:.6f}".format(latitude))
            print("Longitude: {:.6f}".format(longitude))
            print("Speed: {:.2f} km/h".format(speedKmh))

            break

# Convert NMEA coordinate to decimal degrees
def ParseNMEACoordinate(value: str, direction: str) -> float:
    if not value:
        return 0.0

    # Latitude: ddmm.mmmm, Longitude: dddmm.mmmm
    dot_index = value.find('.')
    deg_length = 3 if dot_index > 4 else 2

    deg_str = value[:deg_length]
    min_str = value[deg_length:]

    try:
        degrees = float(deg_str)
        minutes = float(min_str)
    except ValueError:
        return 0.0

    result = degrees + (minutes / 60.0)

    if direction in ("S", "W"):
        result = -result

    return result

# Parse NMEA time hhmmss.ss -> hh:mm:ss
def ParseNMEATime(time_str: str) -> str:
    if len(time_str) < 6:
        return time_str
    hh = time_str[:2]
    mm = time_str[2:4]
    ss = time_str[4:6]
    return "{}:{}:{}".format(hh, mm, ss)

# Parse NMEA date ddmmyy -> yyyy-mm-dd
def ParseNMEADate(date_str: str) -> str:
    if len(date_str) != 6:
        return date_str
    dd = date_str[:2]
    mm = date_str[2:4]
    yy = date_str[4:6]
    year = 2000 + int(yy)
    return "{}-{}-{}".format(year, mm, dd)

# Sample code
data_received = bytearray(512)
due.Uart.Configuration(9600, 2048)

while True:
    total = ReadData(data_received)
    ParseGNRMC(data_received)
    time.sleep(1)  # Sleep 1 second
