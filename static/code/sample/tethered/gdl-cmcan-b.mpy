# This sample runs on QT-PY 2040 adafruit, and may need i2c pullup module
# In this sample:
# On receiving a CAN message, display the RX values and send a CAN message (ID: 1,
# data: {1, 2, 3, 4, 5, 6, 7, 8}). Poll interval: 1 second.

import time
import duelink 

from duelink import transport

sclPIN = machine.Pin(23)
sdaPIN = machine.Pin(22)
 
i2c = transport.I2CTransportController(sda=sdaPIN, scl=sclPIN)
due = duelink.DUELinkController(i2c)

# methods
def Read(data):
    cmd = "dim b1[{}]".format(1 + len(data))  # length at first byte
    due.Engine.ExecuteCommand(cmd)

    ret = int(due.Engine.ExecuteCommand("RxRd(b1)"))

    if ret >= 0:
        id_val = due.Engine.ExecuteCommand("b1[0]")
        print("length: {}".format(id_val))

        for i in range(1, len(data) + 1):
            data[i - 1] = int(due.Engine.ExecuteCommand("b1[{}]".format(i))) & 0xFF
            val = "{:02x}".format(data[i - 1])
            print("Rx data: 0x{}".format(val))

    return ret

def Write(id, data):
    cmd = "dim b0[{}]".format(len(data))  # data length
    due.Engine.ExecuteCommand(cmd)

    for i in range(len(data)):
        due.Engine.ExecuteCommand("b0[{}]={}".format(i, data[i]))

    due.Engine.ExecuteCommand("TxReq({},len(b0),b0)".format(id))
    print("Sent: {}".format(id))

read_arr = bytearray(8)
write_arr = bytearray([1, 2, 3, 4, 5, 6, 7, 8])

while True:
    if Read(read_arr) >= 0:
        Write(1, write_arr)
    time.sleep(1)

