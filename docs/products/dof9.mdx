---
sidebar_position: 70
title: DOF9
description: DOF9 - High-quality DUELink module
hide_table_of_contents: true
pagination_next: null
pagination_prev: null
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ImageSection from '@site/src/components/ImageSection';
import OrderSection from '@site/src/components/OrderSection';

# DOF9

<ImageSection 
  product="sedof9-c"
  tagline="9DoF MEMS Sensor"
/>

---

<Tabs className="unique-tabs" groupid="catalog" queryString="show" defaultValue="overview"
  values={[
    {
        label: "Overview",
        value: "overview"
    },
    {
        label: "Drivers",
        value: "drivers"
    },
    {
        label: "Samples",
        value: "samples"
    }
]}>

<TabItem value="overview">

This 9DoF (Degrees of Freedom) MEMS (Micro Electro Mechanical System) sensor includes 3axis accelerometer, 3axis gyro, & 3axis magnetometer. The combination of these inputs can be used to get exact tilt and orientation.

<table><td width='50%'>
**Key features**

â€¢ 3axis Accelerometer<br/>
â€¢ 3axis Gyro<br/>
â€¢ 3axis Magnetometer<br/>
â€¢ 22x25mm overall dimension<br/>

</td><td width='50%'>
**Resources**
 
ðŸ“„<a href="/sch/gdl-sedof9-c.pdf">Schematics</a><br/>
ðŸ”©<a href="/3d/gdl-sedof9-c.step">3D STEP file</a><br/>
</td></table>

</TabItem>

<TabItem value="drivers">

See [Drivers](/docs/engine/drivers) page for further details.

| Function | Description |
|----------|-------------|
| `RAccel()` | Reads the acceleration XYZ in `_x`, `_y`, `_Z` variables. |
| `RCompass()` | Reads the compass XYZ in `_x`, `_y`, `_Z` variables. |
| `RGyro()` | Reads the gyro XYZ and its internal temp in `_x`, `_y`, `_Z`, `_T` variables. |
| `DVer()` | This driver version. |
<details>
<summary><strong>The Code!</strong></summary>

**DOF9 Driver**

```batch
##### Distance Driver #####
## Priliminary driver. Needs improvements!

fn DVer()
    return 0.1
fend

Alias(ADXL345=0x53, HMC5883= 0x1E, ITG3200=0x68 )

fn Init()
    I2cCfg(400)
    
    #ADXL345 - Accel
    Dim b1[2] = [0x31 , 0x01]
    
    I2cWr(ADXL345, b1, 0)
    
    b1[0] = 0x2D
    b1[1] = 0x08
    I2cWr(ADXL345, b1, 0)
    
    #HMC5883 Compass
    b1[0] = 0x02
    b1[1] = 0x00
    I2cWr(HMC5883, b1, 0)
    
    #ITG3200 Gyro
    b1[0] = 0x03
    b1[1] = 0x00
    I2cWr(ITG3200, b1, 0)
    
    b1[0] = 0x15
    b1[1] = 0x07
    I2cWr(ITG3200, b1, 0)
    
    b1[0] = 0x16
    b1[1] = 0x1E
    I2cWr(ITG3200, b1, 0)
    
    b1[0] = 0x17
    b1[1] = 0x00
    I2cWr(ITG3200, b1, 0)
    
    Wait(10)
    Dim b6[6]
    Dim b2[8]
fend

fn RAccel()
    
    I2cWr(ADXL345, [0x32], 0) # write to register
    
    v = I2cWr(ADXL345, 0, b6) # read from register, b6 need 6 bytes
    
    if (v = 0)
        PrintLn("Init Accel failed")
        while (1)
        wend
    end
    _x = Convert(b6[1], b6[0])
    _y = Convert(b6[3], b6[2])
    _z = Convert(b6[5], b6[4])
fend

fn RCompass()
    
    I2cWr(HMC5883, [0x3], 0) # write to register
    
    v = I2cWr(HMC5883, 0, b6) # read from register, b2 need 6 bytes
    
    if (v = 0)
        PrintLn("Init compass failed")
        while (1)
        wend
    end
    _x = Convert(b6[0], b6[1])
    _y = Convert(b6[2], b6[3])
    _z = Convert(b6[4], b6[5])
fend

fn RGyro()
    
    I2cWr(ITG3200, [0x1B], 0) # write to register
    v = I2cWr(ITG3200, 0, b2) # read from register, b2 need 8 bytes
    
    if (v = 0)
        PrintLn("Init Gyro failed")
        while (1)
        wend
    end
    
    _x = Convert(b2[2], b2[3])
    _y = Convert(b2[4], b2[5])
    _z = Convert(b2[6], b2[7])
    _t = Convert(b2[0], b2[1])  
    _t = 35 + (_t + 13200)/280
fend

fn Convert(u,l)
    v = (u << 8) | l
    if v > 32768
        v = 65536 - v
        v = v * -1
    end
    return v
    # Here is another way to convert!
    if(u&080)
        u = (~u)& 0xff
        l = (~l)& 0xff
        return (((u<<8) | l)*-1)-1
    else
        return (u<<8) | l
    end
fend

Init()

##############################
```

</details>

[See full driver on GitHub](https://github.com/ghi-electronics/duelink-website/tree/main/static/code/drivers)

</TabItem>

<TabItem value="samples">

### Python

```python
from DUELink.DUELinkController import DUELinkController
import time
availablePort = DUELinkController.GetConnectionPort()
duelink = DUELinkController(availablePort)
```

### JavaScript

```javascript
const { SerialUSB } = require("dlserialusb");
const { DUELinkController } = require("duelink");
```

### Script

```batch
while (1)  
    RAccel()
    PrintLn("accel XYZ: ",_x," ",_y," ",_z)
    
    RCompass()
    PrintLn("Compass XYZ: ", _x, " ", _y, " ", _z)
    
    RGyro()
    PrintLn("Gyro XYZT: ",_x," ",_y," ",_z," ",_t)
    
    # This can take a while sometimes. Is this correct?
    #while (dread(14, 1) = 1) # Wait for m_ready ready
    #    Wait(1)
    #wend
    
    Wait(100)    
wend

```

[See full examples on GitHub](https://github.com/ghi-electronics/duelink-website/tree/main/static/code/samples)

</TabItem>

</Tabs>

---

<OrderSection
    product="DUELink DOF9"
    partnumber="GDL-SEDOF9-C"
    price="$0.00"
/>
