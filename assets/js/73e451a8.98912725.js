"use strict";(self.webpackChunkduelink=self.webpackChunkduelink||[]).push([[8707],{7356:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"interface/i2c","title":"I2C","description":"---","source":"@site/docs/interface/i2c.mdx","sourceDirName":"interface","slug":"/interface/i2c","permalink":"/docs/interface/i2c","draft":false,"unlisted":false,"editUrl":"https://github.com/ghi-electronics/duelink-website/tree/dev/docs/interface/i2c.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"USB","permalink":"/docs/interface/usb"},"next":{"title":"UART (Serial)","permalink":"/docs/interface/uart"}}');var t=i(4848),r=i(8453);const o={},a="I2C",l={},d=[{value:"Microcomputers",id:"microcomputers",level:2},{value:"The Protocol",id:"the-protocol",level:2},{value:"Mixing Module Types",id:"mixing-module-types",level:2},{value:"Pull Up Resistors",id:"pull-up-resistors",level:2}];function c(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",p:"p",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"i2c",children:"I2C"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["I2C is the most common interface when selecting a microcontroller-level ",(0,t.jsx)(n.a,{href:"../hw/intro",children:"Hardware"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"microcomputers",children:"Microcomputers"}),"\n",(0,t.jsx)(n.p,{children:"Many Microcomputers today include JST connectors that uses I2C bus. Some companies have standards around the same JST connector, such as Sparkfun QWIIC and Adafruit STEMMA products."}),"\n",(0,t.jsxs)(n.p,{children:["A good example is Arduino UNO R4 WiFi. ",(0,t.jsx)(n.a,{href:"../hw/arduino",children:"Arduino"})," is one the ",(0,t.jsx)(n.a,{href:"../hw/intro",children:"Supported Hardware"})," options, providing all the necessary libraries."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/arduino-uno-r4-wifi.png",alt:"Arduino Uno R4 Wifi"})}),"\n",(0,t.jsx)(n.p,{children:"Another example is Sparkfun Redboard."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/redboard-duelink-display.png",alt:"Sparkfun Redboard with DUELink"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that typical use of non-DUELink I2C on JST connector is done by connecting all modules on the same I2C signals. This is defiantly not the case with DUELink. DUELink only uses I2C on the first module. Then that modules connects to other modules using the ",(0,t.jsx)(n.a,{href:"../interface/downlink",children:"Downlink"})," interface. This typology does not consume I2C addresses and allows for ",(0,t.jsx)(n.a,{href:"../engine/daisylink",children:"Daisylinking"})," hundreds of modules!"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"the-protocol",children:"The Protocol"}),"\n",(0,t.jsx)(n.p,{children:"A DUELink module is always an I2C slave listening to an I2C bus master on address is 0x52 (7bit), which is fixed and can't be changed."}),"\n",(0,t.jsx)(n.p,{children:"The host (I2C master) can send data as individual bytes or multiple bytes. The module will look at individual bytes and disregard how they're packed in frames. In other words, start, restart, and stop conditions are ignored by the data stream."}),"\n",(0,t.jsx)(n.p,{children:"The module (slave) will return 0xFF when the host request data but the device does not have any data to return."}),"\n",(0,t.jsx)(n.p,{children:"When the device is too busy to accept data, it will use clock stretching feature. Clock stretching support is a standard I2C feature and is required from the host."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"mixing-module-types",children:"Mixing Module Types"}),"\n",(0,t.jsxs)(n.p,{children:["Many modules on the market include a JST connector with I2C bus signals. They simply use I2C and most will not have any intelligence. DUELink gracefully allows for these modules to be connected on the same ",(0,t.jsx)(n.a,{href:"../engine/daisylink",children:"Daisylink"}),". The only rule is you have to connect the non-DUELink modules first in the chain. Access those module like you normally would, as DUELink will simply ignore them."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/qwiic-stemma-duelink.png",alt:"QWIIC and STEMMA QT with DUELink modules"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"You can't use any non-DUELink modules that have the same address as DUELink, which is very unlikely!"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pull-up-resistors",children:"Pull Up Resistors"}),"\n",(0,t.jsxs)(n.p,{children:["I2C requires pull up resistors to operate, typically 2.2K. Some boards on the market do not include these resistors. Instead, they rely on the internal weak pull up resistors inside the micro. This may cause problems in some cases. DUELink has a ",(0,t.jsx)(n.a,{href:"../catalog/accessory/pullup",children:"PullUp"})," module to solve this issue."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/qtpy-pullup.png",alt:"QTPY with Pull-up"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);